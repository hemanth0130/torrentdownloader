<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>torrentDownloader — Paste magnet or upload .torrent</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- Inter font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <!-- Tailwind config + CDN -->
  <script>
    tailwind = window.tailwind || {};
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: { sans: ['Inter','system-ui','-apple-system','BlinkMacSystemFont','sans-serif'] },
          colors: { accent: { DEFAULT: '#38bdf8' } },
          boxShadow: { 'soft': '0 18px 45px rgba(0,0,0,0.6)' }
        }
      }
    };
  </script>
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- WebTorrent (browser) -->
  <script src="https://cdn.jsdelivr.net/npm/webtorrent@latest/webtorrent.min.js"></script>

  <style>
    .line-clamp-2 { display:-webkit-box; -webkit-line-clamp:2; -webkit-box-orient:vertical; overflow:hidden; }
    /* Ensure long input doesn't push the button out on small screens */
    @media (max-width: 480px) {
      .input-row { gap: 8px; }
    }
  </style>
</head>
<body class="min-h-screen bg-slate-950 text-slate-100 font-sans antialiased">
  <div class="max-w-4xl mx-auto p-4 pb-10">
    <!-- Header -->
    <header class="flex items-center justify-between gap-4 mb-6">
      <div class="flex items-center gap-3">
        <div class="h-10 w-10 rounded-2xl bg-gradient-to-br from-accent to-sky-500 flex items-center justify-center shadow-soft">
          <span class="text-xs font-bold uppercase">TD</span>
        </div>
        <div>
          <h1 class="text-xl font-semibold">torrent<span class="text-accent">Downloader</span></h1>
          <p class="text-xs text-slate-400">Paste magnet or upload .torrent — download in-browser (WebTorrent)</p>
        </div>
      </div>
    </header>

    <!-- Search / Paste Area -->
    <section class="mb-6">
      <div class="relative">
        <div class="pointer-events-none absolute inset-y-0 left-0 flex items-center pl-4">
          <svg class="h-5 w-5 text-slate-500" viewBox="0 0 24 24" fill="none"><path d="M15.5 15.5L20 20" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/><circle cx="11" cy="11" r="6" stroke="currentColor" stroke-width="1.6"/></svg>
        </div>
        <input id="searchInput" type="search" placeholder="Search 15 Million+ verified links..." class="w-full h-12 rounded-full bg-slate-900/90 border border-slate-800 text-sm text-slate-100 placeholder:text-slate-500 pl-11 pr-4 focus:outline-none focus:ring-2 focus:ring-accent/60" />
      </div>
      <p class="mt-2 text-xs text-slate-500">Tip: You can paste a <span class="font-medium">magnet:?xt=urn:btih:</span> link below, or upload a <code class="text-xs px-1 py-0.5 rounded bg-slate-800">.torrent</code> file.</p>
    </section>

    <!-- Paste / upload card (legal notice removed per request) -->
    <section class="mb-6">
      <div class="rounded-2xl border border-slate-800 bg-slate-900/70 p-4">
        <label class="block text-xs text-slate-400 mb-2">Paste Magnet Link or Info Hash</label>

        <!-- Important: use a row where button is fixed width and cannot be pushed out -->
        <div class="flex input-row items-center">
          <input id="magnetInput" type="text" inputmode="url" placeholder="magnet:?xt=urn:btih:..." class="flex-1 h-12 rounded-xl bg-slate-900 border border-slate-800 px-4 text-sm text-slate-100 placeholder:text-slate-500 focus:ring-2 focus:ring-accent/50" />
          <button id="addMagnetBtn" class="ml-2 flex-shrink-0 min-w-[72px] h-12 px-3 rounded-xl bg-accent text-slate-950 font-semibold">Add</button>
        </div>

        <div class="mt-4">
          <label class="block text-xs text-slate-400 mb-2">Or upload a .torrent file</label>
          <div class="flex gap-2 items-center">
            <input id="torrentFile" type="file" accept=".torrent" class="hidden" />
            <button id="chooseFileBtn" class="h-12 px-4 rounded-xl bg-slate-800 border border-slate-700 text-sm text-slate-200">Choose File</button>
            <div id="fileLabel" class="text-xs text-slate-400">No file chosen</div>
            <div class="ml-auto text-xs text-slate-500">Runs in your browser</div>
          </div>
        </div>
      </div>
    </section>

    <!-- Active torrent area -->
    <section id="activeArea" class="mb-6 hidden">
      <div class="rounded-2xl border border-slate-800 bg-slate-900/60 p-4">
        <div class="flex items-center justify-between gap-3 mb-3">
          <div class="min-w-0">
            <h2 id="torrentName" class="text-sm font-semibold text-slate-100 line-clamp-2">Adding...</h2>
            <div id="torrentStats" class="text-xs text-slate-400 mt-1">Waiting for metadata...</div>
          </div>
          <div class="text-right">
            <div id="peerCount" class="text-xs text-slate-400">Peers: 0</div>
            <button id="destroyBtn" class="mt-2 text-xs px-3 py-2 rounded-lg bg-slate-800 border border-slate-700">Stop</button>
          </div>
        </div>

        <div class="w-full bg-slate-800 rounded-full h-3 overflow-hidden">
          <div id="progressBar" class="h-3 bg-accent w-0 transition-all"></div>
        </div>

        <div id="filesList" class="mt-4 space-y-3"></div>

        <div id="metaNotice" class="mt-3 text-xs text-slate-400 hidden"></div>
      </div>
    </section>

    <!-- Simulated results (kept for discovery) -->
    <main aria-live="polite">
      <div id="resultsList" class="space-y-3"></div>
      <div id="emptyState" class="hidden mt-10 text-center text-slate-500">No torrents match your search. Try different keywords.</div>
    </main>
  </div>

<script>
/* =========================
   Core data + UI
   ========================= */

const sampleTorrents = [
  { title:'The Last Frontier - S01E01 - 1080p WEBRip [YTS]', size:'1.5 GB', type:'TV / Series', seeders:5421, leechers:12, hash:'9F2A0B3D8C4F7E91A2B3C4D5E6F7A8B9C0D1E2F' },
  { title:'Interstellar (2014) 2160p UHD BluRay x265 [YTS]', size:'19.4 GB', type:'Movie', seeders:8322, leechers:71, hash:'7E1F9A3B4C5D6E7F8A9B0C1D2E3F4A5B6C7D8E9F' },
  { title:'Ubuntu 24.04 LTS Desktop ISO x64', size:'4.2 GB', type:'Software / OS', seeders:12014, leechers:89, hash:'4A5B6C7D8E9F0A1B2C3D4E5F6A7B8C9D0E1F2A3B' },
];

const resultsList = document.getElementById('resultsList');
const emptyState = document.getElementById('emptyState');
const searchInput = document.getElementById('searchInput');
const magnetInput = document.getElementById('magnetInput');
const addMagnetBtn = document.getElementById('addMagnetBtn');
const chooseFileBtn = document.getElementById('chooseFileBtn');
const torrentFileInput = document.getElementById('torrentFile');
const fileLabel = document.getElementById('fileLabel');

const activeArea = document.getElementById('activeArea');
const torrentNameEl = document.getElementById('torrentName');
const torrentStatsEl = document.getElementById('torrentStats');
const peerCountEl = document.getElementById('peerCount');
const progressBar = document.getElementById('progressBar');
const filesList = document.getElementById('filesList');
const destroyBtn = document.getElementById('destroyBtn');
const metaNotice = document.getElementById('metaNotice');

let client = null;
let activeTorrent = null;
let metadataTimer = null;

/* WSS trackers for WebRTC */
const DEFAULT_WSS_TRACKERS = [
  'wss://tracker.openwebtorrent.com',
  'wss://tracker.btorrent.xyz',
  'wss://tracker.fastcast.nz',
  'wss://tracker.webtorrent.io',
  'wss://tracker.opentrackr.org',
  'wss://tracker.skyts.net',
];

/* normalize input to magnet if it's just an info-hash */
function normalizeToMagnet(input) {
  if (!input) return null;
  input = input.trim();
  if (/^magnet:\?/i.test(input)) return input;
  input = input.replace(/^<|>$/g, '').replace(/^"|"$/g, '');
  const hexMatch = input.match(/^[0-9a-fA-F]{40}$/);
  const base32Match = input.match(/^[A-Z2-7]{32}$/i);
  if (hexMatch || base32Match) {
    const trackers = DEFAULT_WSS_TRACKERS.map(t => `&tr=${encodeURIComponent(t)}`).join('');
    return `magnet:?xt=urn:btih:${input}${trackers}`;
  }
  return null;
}

function buildMagnetForSample(t) {
  const trackers = DEFAULT_WSS_TRACKERS.map(tk => `&tr=${encodeURIComponent(tk)}`).join('');
  return `magnet:?xt=urn:btih:${t.hash}&dn=${encodeURIComponent(t.title)}${trackers}`;
}

/* Render simulated results */
function renderResults(list) {
  resultsList.innerHTML = '';
  if (!list.length) { emptyState.classList.remove('hidden'); return; }
  emptyState.classList.add('hidden');

  list.forEach(t => {
    const card = document.createElement('article');
    card.className = 'bg-slate-900/80 border border-slate-800 rounded-2xl p-4 flex flex-col md:flex-row md:items-center md:justify-between gap-3';
    card.innerHTML = `
      <div class="flex-1 min-w-0">
        <h3 class="text-sm font-semibold text-slate-100 line-clamp-2">${escapeHtml(t.title)}</h3>
        <div class="mt-2 flex flex-wrap items-center gap-2 text-xs text-slate-400">
          <span class="inline-flex items-center rounded-full bg-slate-800/80 px-2 py-1">Size: ${t.size}</span>
          <span class="inline-flex items-center rounded-full bg-slate-800/80 px-2 py-1">${t.type}</span>
          <span class="inline-flex items-center gap-1 px-1.5 py-1"><span class="text-emerald-400 font-semibold">${t.seeders.toLocaleString()}</span><span class="text-slate-500">Seeders</span></span>
          <span class="inline-flex items-center gap-1 px-1.5 py-1"><span class="text-orange-400 font-semibold">${t.leechers.toLocaleString()}</span><span class="text-slate-500">Leechers</span></span>
        </div>
        <p class="mt-1 text-[11px] text-slate-500 break-all">Info Hash: <span class="text-slate-400">${t.hash}</span></p>
      </div>
      <div class="flex flex-col items-stretch md:items-end gap-2 w-full md:w-auto">
        <button class="copy-btn mt-2 md:mt-0 inline-flex items-center justify-center w-full md:w-auto rounded-xl bg-accent px-4 py-3 text-xs md:text-sm font-semibold text-slate-950 transition">Copy Magnet Link</button>
        <button class="add-btn mt-2 md:mt-0 inline-flex items-center justify-center w-full md:w-auto rounded-xl bg-slate-800 text-xs md:text-sm font-semibold text-slate-100 transition">Open / Add</button>
      </div>
    `;
    resultsList.appendChild(card);

    const copyBtn = card.querySelector('.copy-btn');
    copyBtn.dataset.magnet = buildMagnetForSample(t);
    copyBtn.addEventListener('click', () => copyToClipboard(copyBtn.dataset.magnet, copyBtn));

    const addBtn = card.querySelector('.add-btn');
    addBtn.addEventListener('click', () => { startAddMagnet(buildMagnetForSample(t)); window.scrollTo({ top: 0, behavior: 'smooth' }); });
  });

  attachCopyHandlers();
}

/* escaping */
function escapeHtml(s){ return (s+'').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

/* Copy helpers */
function showCopyFeedback(button) {
  const orig = button.textContent.trim();
  const origClass = button.className;
  button.textContent = 'Copied!';
  button.className = 'inline-flex items-center justify-center rounded-xl bg-emerald-500 px-4 py-3 text-xs font-semibold text-slate-950';
  setTimeout(()=> { button.textContent = orig; button.className = origClass; }, 1100);
}
function fallbackCopy(text, button) {
  const ta = document.createElement('textarea'); ta.value = text; ta.style.position='fixed'; ta.style.left='-9999px';
  document.body.appendChild(ta); ta.select();
  try { document.execCommand('copy'); showCopyFeedback(button); } catch(e) { alert('Copy failed.'); }
  document.body.removeChild(ta);
}
function copyToClipboard(text, button) {
  if (!text) return;
  if (navigator.clipboard && window.isSecureContext) {
    navigator.clipboard.writeText(text).then(()=>showCopyFeedback(button)).catch(()=>fallbackCopy(text,button));
  } else fallbackCopy(text, button);
}
function attachCopyHandlers() {
  document.querySelectorAll('.copy-btn').forEach(btn => {
    btn.addEventListener('click', ()=> {
      copyToClipboard(btn.dataset.magnet, btn);
    });
  });
}

/* Search */
function filterTorrents(q) {
  const s = (q||'').trim().toLowerCase();
  if (!s) return sampleTorrents;
  return sampleTorrents.filter(t => t.title.toLowerCase().includes(s) || t.type.toLowerCase().includes(s) || t.size.toLowerCase().includes(s));
}
searchInput.addEventListener('input', (e)=> renderResults(filterTorrents(e.target.value)));
renderResults(sampleTorrents);

/* =========================
   WebTorrent: Add / Manage
   ========================= */

function ensureClient() {
  if (!client) {
    try { client = new WebTorrent(); } catch (e) { console.error('WebTorrent init', e); alert('WebTorrent unavailable in this environment.'); }
  }
}

function startAddMagnet(rawInput) {
  const magnet = normalizeToMagnet(rawInput) || rawInput;
  if (!magnet || !magnet.startsWith('magnet:?')) {
    metaNotice.classList.remove('hidden');
    metaNotice.textContent = 'Invalid magnet or info-hash. Please paste a full magnet:? link or upload a .torrent file.';
    return;
  }
  addTorrent(magnet);
}

/* Add torrent but DO NOT auto-download files. Files are deselected by default and only start when user taps Download. */
function addTorrent(magnetOrBuffer) {
  ensureClient();
  if (!client) return;

  if (activeTorrent) { try { activeTorrent.destroy(); } catch(e){} activeTorrent = null; }
  clearMetadataTimer();

  activeArea.classList.remove('hidden');
  filesList.innerHTML = '';
  metaNotice.classList.add('hidden');
  torrentNameEl.textContent = 'Adding...';
  torrentStatsEl.textContent = 'Waiting for metadata...';
  progressBar.style.width = '0%';
  peerCountEl.textContent = 'Peers: 0';

  metadataTimer = setTimeout(()=> {
    if (activeTorrent && activeTorrent.files && activeTorrent.files.length) return;
    metaNotice.classList.remove('hidden');
    metaNotice.textContent = 'Unable to fetch metadata / connect to peers within 20s. Try uploading the .torrent file or try a native client.';
  }, 20000);

  try {
    client.add(magnetOrBuffer, { announce: DEFAULT_WSS_TRACKERS }, (torrent) => {
      activeTorrent = torrent;
      torrentNameEl.textContent = torrent.name || 'Unnamed torrent';
      updateStats();
      peerCountEl.textContent = `Peers: ${torrent.numPeers || 0}`;

      // When metadata is present, we'll display files, but ensure we DO NOT auto-select/download pieces:
      const onHaveMetadata = () => {
        // Deselect all files to prevent automatic download in browser:
        try {
          if (torrent.files && torrent.files.length) {
            torrent.files.forEach(f => {
              // some file objects expose deselect(); call safely if present
              if (typeof f.deselect === 'function') {
                try { f.deselect(); } catch(e) {}
              }
            });
          }
        } catch(e) { console.warn('deselect error', e); }

        populateFiles(torrent);
        clearMetadataTimer();
      };

      if (torrent.files && torrent.files.length) onHaveMetadata();
      else torrent.on('metadata', onHaveMetadata);

      // progress updates
      const updater = setInterval(() => {
        if (!activeTorrent) { clearInterval(updater); return; }
        updateStats();
      }, 700);

      torrent.on('done', () => {
        progressBar.style.width = '100%';
        torrentStatsEl.textContent = `Completed • Peers: ${torrent.numPeers || 0}`;
        clearInterval(updater);
      });

      torrent.on('wire', () => updateStats());
    });
  } catch (err) {
    console.error('Add torrent error', err);
    metaNotice.classList.remove('hidden');
    metaNotice.textContent = 'Failed to add torrent. The browser may block WebRTC or the magnet is invalid.';
    clearMetadataTimer();
  }
}

function clearMetadataTimer() { if (metadataTimer) { clearTimeout(metadataTimer); metadataTimer = null; } }

function populateFiles(torrent) {
  filesList.innerHTML = '';
  if (!torrent.files || !torrent.files.length) {
    filesList.innerHTML = '<div class="text-xs text-slate-400">No files in this torrent.</div>';
    return;
  }

  torrent.files.forEach(file => {
    const row = document.createElement('div');
    row.className = 'flex items-center justify-between gap-3 bg-slate-900/70 p-3 rounded-xl border border-slate-800';
    row.innerHTML = `
      <div class="min-w-0">
        <div class="text-sm font-medium text-slate-100 line-clamp-1">${escapeHtml(file.name)}</div>
        <div class="text-xs text-slate-400 mt-1">${(file.length / (1024*1024)).toFixed(2)} MB</div>
      </div>
      <div class="flex-shrink-0 flex items-center gap-2">
        <button class="btn-download px-3 py-2 rounded-lg bg-accent text-slate-950 text-xs font-semibold">Download</button>
      </div>
    `;
    filesList.appendChild(row);

    const dlBtn = row.querySelector('.btn-download');
    dlBtn.addEventListener('click', () => {
      dlBtn.disabled = true;
      dlBtn.textContent = 'Preparing...';

      // Before requesting blob, select the file to fetch pieces
      try {
        if (typeof file.select === 'function') {
          try { file.select(); } catch(e){ console.warn('file.select failed', e); }
        }
      } catch(e) { console.warn('select error', e); }

      // Download to blob then offer for saving
      try {
        file.getBlob((err, blob) => {
          if (err || !blob) {
            console.error('getBlob error', err);
            dlBtn.textContent = 'Failed';
            setTimeout(()=> { dlBtn.disabled=false; dlBtn.textContent='Download'; }, 1400);
            return;
          }
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = file.name;
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
          dlBtn.textContent = 'Saved';
          setTimeout(()=> { dlBtn.disabled=false; dlBtn.textContent='Download'; }, 1200);
        });
      } catch (e) {
        console.error('download exception', e);
        dlBtn.textContent = 'Error';
        setTimeout(()=> { dlBtn.disabled=false; dlBtn.textContent='Download'; }, 1200);
      }
    });
  });
}

function updateStats() {
  if (!activeTorrent) return;
  const t = activeTorrent;
  const percent = Math.round((t.progress || 0) * 10000) / 100;
  progressBar.style.width = `${percent}%`;
  torrentStatsEl.textContent = `${percent}% • ${formatSpeed(t.downloadSpeed || 0)}/s • ${(t.length / (1024*1024)).toFixed(0)} MB total`;
  peerCountEl.textContent = `Peers: ${t.numPeers || 0}`;
}

function formatSpeed(bytesPerSec) {
  if (!bytesPerSec) return '0 KB';
  const units = ['B','KB','MB','GB'];
  let b = bytesPerSec;
  let u = 0;
  while (b >= 1024 && u < units.length-1) { b /= 1024; u++; }
  return `${b.toFixed(2)} ${units[u]}`;
}

/* Stop / destroy */
destroyBtn.addEventListener('click', () => {
  if (activeTorrent) { try { activeTorrent.destroy(); } catch(e){} activeTorrent = null; }
  progressBar.style.width = '0%';
  filesList.innerHTML = '';
  activeArea.classList.add('hidden');
  metaNotice.classList.add('hidden');
});

/* UI handlers */
addMagnetBtn.addEventListener('click', () => {
  const raw = magnetInput.value.trim();
  if (!raw) { magnetInput.focus(); return; }
  startAddMagnet(raw);
});
magnetInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') addMagnetBtn.click(); });

chooseFileBtn.addEventListener('click', () => torrentFileInput.click());
torrentFileInput.addEventListener('change', (ev) => {
  const f = ev.target.files && ev.target.files[0];
  if (!f) { fileLabel.textContent = 'No file chosen'; return; }
  fileLabel.textContent = f.name;
  const reader = new FileReader();
  reader.onload = function() {
    const arr = new Uint8Array(this.result);
    addTorrent(arr);
  };
  reader.onerror = function() {
    metaNotice.classList.remove('hidden');
    metaNotice.textContent = 'Failed to read .torrent file.';
  };
  reader.readAsArrayBuffer(f);
});

/* cleanup */
window.addEventListener('beforeunload', () => {
  if (activeTorrent) try { activeTorrent.destroy(); } catch(e){}
  if (client) try { client.destroy(); } catch(e){}
});
</script>
</body>
</html>
