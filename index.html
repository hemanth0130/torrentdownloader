<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>torrentDownloader</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet"/>
  
  <script>
    // Configuration for Tailwind
    tailwind = window.tailwind || {};
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: { sans: ['Inter','system-ui','-apple-system','BlinkMacSystemFont','sans-serif'] },
          colors: { accent: { DEFAULT: '#38bdf8' } },
          boxShadow: { 'soft': '0 18px 45px rgba(0,0,0,0.6)' }
        }
      }
    };
  </script>
  <script src="https://cdn.tailwindcss.com"></script>

  <script src="https://cdn.jsdelivr.net/npm/webtorrent@latest/webtorrent.min.js"></script>

  <style>
    /* Custom CSS for visual layout */
    .line-clamp-2 { display:-webkit-box; -webkit-line-clamp:2; -webkit-box-orient:vertical; overflow:hidden; }
    .magnet-row { position: relative; }
    .magnet-input { padding-right: 110px; } 
    .magnet-add-btn {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      min-width: 84px;
      height: 44px;
      border-radius: 12px;
      z-index: 10;
      transition: all 0.15s ease-in-out;
    }
    .magnet-add-btn:disabled { opacity: 0.5; cursor: not-allowed; }

    @media (min-width: 768px) {
      .magnet-input { padding-right: 150px; }
      .magnet-add-btn { min-width: 110px; height:48px; right:12px; border-radius:14px; }
    }
  </style>
</head>
<body class="min-h-screen bg-slate-950 text-slate-100 font-sans antialiased">
  <div class="max-w-3xl mx-auto p-4 pb-12">
    
    <header class="flex items-center gap-3 mb-6">
      <div class="h-10 w-10 rounded-2xl bg-gradient-to-br from-accent to-sky-500 flex items-center justify-center shadow-soft">
        <span class="text-xs font-bold uppercase">TD</span>
      </div>
      <div>
        <h1 class="text-xl font-semibold">torrent<span class="text-accent">Downloader</span></h1>
        <p class="text-xs text-slate-400">Paste magnet or upload a .torrent file ‚Äî then download files or open in a native client.</p>
      </div>
    </header>

    <div id="capBanner" class="mb-4 hidden rounded-xl p-3 text-sm"></div>

    <section class="mb-6">
      <div class="rounded-2xl border border-slate-800 bg-slate-900/70 p-4">
        <label class="block text-xs text-slate-400 mb-2">Paste Magnet Link or Info Hash</label>

        <div class="magnet-row mb-3">
          <input id="magnetInput" class="magnet-input w-full h-12 rounded-xl bg-slate-900 border border-slate-800 px-4 text-sm text-slate-100 placeholder:text-slate-500 focus:ring-2 focus:ring-accent/50" type="text" inputmode="url" placeholder="magnet:?xt=urn:btih:..." />
          <button id="addMagnetBtn" class="magnet-add-btn bg-accent text-slate-950 font-semibold">Add</button>
        </div>

        <div class="mt-1">
          <label class="block text-xs text-slate-400 mb-2">Or upload a .torrent file</label>
          <div class="flex gap-2 items-center">
            <input id="torrentFile" type="file" accept=".torrent" class="hidden" />
            <button id="chooseFileBtn" class="h-12 px-4 rounded-xl bg-slate-800 border border-slate-700 text-sm text-slate-200">Choose File</button>
            <div id="fileLabel" class="text-xs text-slate-400">No file chosen</div>
            <div class="ml-auto text-xs text-slate-500">Runs in your browser</div>
          </div>
        </div>
      </div>
    </section>

    <section id="activeArea" class="mb-6 hidden">
      <div class="rounded-2xl border border-slate-800 bg-slate-900/60 p-4">
        <div class="flex items-center justify-between gap-3 mb-3">
          <div class="min-w-0">
            <h2 id="torrentName" class="text-sm font-semibold text-slate-100 line-clamp-2">Adding...</h2>
            <div id="torrentStats" class="text-xs text-slate-400 mt-1">Waiting for metadata...</div>
          </div>
          <div class="text-right">
            <div id="peerCount" class="text-xs text-slate-400">Peers: 0</div>
            <button id="destroyBtn" class="mt-2 text-xs px-3 py-2 rounded-lg bg-slate-800 border border-slate-700 hover:bg-slate-700 transition">Stop</button>
          </div>
        </div>

        <div class="w-full bg-slate-800 rounded-full h-3 overflow-hidden">
          <div id="progressBar" class="h-3 bg-accent w-0 transition-all"></div>
        </div>

        <div id="filesList" class="mt-4 space-y-3"></div>

        <div id="metaNotice" class="mt-3 text-xs text-rose-400 hidden"></div>

        <div id="nativeActionRow" class="mt-4 hidden flex flex-col gap-3">
          <div class="flex gap-3">
            <button id="openNativeBtn" class="flex-1 rounded-xl py-3 text-sm font-semibold bg-sky-600 text-slate-950 hover:bg-sky-500 transition">Open in native app</button>
            <button id="copyMagnetForNative" class="rounded-xl px-4 py-3 bg-slate-800 text-sm hover:bg-slate-700 transition">Copy Magnet</button>
          </div>
          <div class="text-xs text-slate-500">If browser cannot connect (common on iOS), tap ‚ÄúOpen in native app‚Äù to hand the magnet to a native torrent client.</div>
        </div>
      </div>
    </section>

  </div>

<script>
/* ============
   Config & DOM
   ============ */

const DEFAULT_WSS_TRACKERS = [
  'wss://tracker.openwebtorrent.com',
  'wss://tracker.btorrent.xyz',
  'wss://tracker.fastcast.nz',
  'wss://tracker.webtorrent.io',
  'wss://tracker.opentrackr.org',
  'wss://tracker.skyts.net',
  'wss://ws.btorrent.xyz' // Added another common one for redundancy
].map(t => `&tr=${encodeURIComponent(t)}`).join(''); // Format for magnet link construction

const capBanner = document.getElementById('capBanner');
const magnetInput = document.getElementById('magnetInput');
const addMagnetBtn = document.getElementById('addMagnetBtn');
const torrentFileInput = document.getElementById('torrentFile');
const fileLabel = document.getElementById('fileLabel');

const activeArea = document.getElementById('activeArea');
const torrentNameEl = document.getElementById('torrentName');
const torrentStatsEl = document.getElementById('torrentStats');
const peerCountEl = document.getElementById('peerCount');
const progressBar = document.getElementById('progressBar');
const filesList = document.getElementById('filesList');
const destroyBtn = document.getElementById('destroyBtn');
const metaNotice = document.getElementById('metaNotice');
const nativeActionRow = document.getElementById('nativeActionRow');
const openNativeBtn = document.getElementById('openNativeBtn');
const copyMagnetForNative = document.getElementById('copyMagnetForNative');

let client = null;
let activeTorrent = null;
let metadataTimer = null;
let statsUpdater = null;

/* ============
   Capability check
   ============ */

function supportsWebRTC() {
  const rtc = typeof RTCPeerConnection !== 'undefined' || typeof webkitRTCPeerConnection !== 'undefined' || typeof mozRTCPeerConnection !== 'undefined';
  const ws = typeof WebSocket !== 'undefined';
  return rtc && ws;
}

function showCapabilityBanner() {
  const isSupported = supportsWebRTC();
  capBanner.classList.remove('hidden');

  if (!isSupported) {
    capBanner.className = 'mb-4 rounded-xl p-3 text-sm bg-rose-900/60 text-rose-200';
    capBanner.innerHTML = '‚ö†Ô∏è **Browser not suitable for in-browser torrenting.** Use "Open in native app" or try desktop Chrome/Firefox.';
  } else {
    capBanner.className = 'mb-4 rounded-xl p-2 text-sm bg-emerald-900/10 text-emerald-300 border border-emerald-800';
    capBanner.textContent = '‚úÖ Browser supports WebRTC; in-browser torrenting may work (requires WebRTC-capable peers).';
    setTimeout(()=> capBanner.classList.add('hidden'), 3000);
  }
}
showCapabilityBanner();

/* ============
   Helpers
   ============ */

function escapeHtml(s){ return (s+'').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

function normalizeToMagnet(input) {
  if (!input) return null;
  input = input.trim();
  if (/^magnet:\?/i.test(input)) return input;
  
  // Clean up input that might be wrapped in quotes or tags
  input = input.replace(/^<|>$/g, '').replace(/^"|"$/g, '');
  
  // Check for 40-character hex info-hash
  const hexMatch = input.match(/^[0-9a-fA-F]{40}$/);
  // Check for 32-character base32 info-hash
  const base32Match = input.match(/^[A-Z2-7]{32}$/i);
  
  if (hexMatch || base32Match) {
    // Construct magnet link with pre-formatted trackers
    return `magnet:?xt=urn:btih:${input}${DEFAULT_WSS_TRACKERS}`;
  }
  return null;
}

function copyToClipboard(text, buttonFallback) {
  if (!text) return;
  const originalText = buttonFallback ? buttonFallback.textContent : 'Copy';
  
  // Uses modern navigator.clipboard API if available and secure
  if (navigator.clipboard && window.isSecureContext) {
    navigator.clipboard.writeText(text).then(()=> {
      if (buttonFallback) {
        buttonFallback.textContent = '‚úÖ Copied';
        setTimeout(()=> buttonFallback.textContent = originalText, 1000);
      }
    }).catch(()=> fallbackCopy(text, buttonFallback, originalText)); // Fallback if modern API fails
  } else {
    fallbackCopy(text, buttonFallback, originalText);
  }
}

function fallbackCopy(text, btn, originalText) {
  const ta = document.createElement('textarea'); ta.value = text; 
  ta.style.position='fixed'; ta.style.left='-9999px';
  document.body.appendChild(ta); ta.select();
  try { 
    document.execCommand('copy'); 
    if (btn){ 
      btn.textContent='‚úÖ Copied'; 
      setTimeout(()=>btn.textContent=originalText,1000);
    } 
  } catch(e){ 
    alert('Copy failed: Your browser does not support automatic clipboard access.'); 
    if (btn) btn.textContent = originalText;
  }
  document.body.removeChild(ta);
}

function clearUiState() {
    filesList.innerHTML = '';
    activeArea.classList.add('hidden');
    metaNotice.classList.add('hidden');
    nativeActionRow.classList.add('hidden');
    progressBar.style.width = '0%';
    torrentNameEl.textContent = 'Adding...';
    torrentStatsEl.textContent = 'Waiting for metadata...';
    peerCountEl.textContent = 'Peers: 0';
}

/* ============
   WebTorrent logic
   ============ */

function ensureClient() {
  if (!client && supportsWebRTC()) {
    // WebTorrent uses global WebTorrent object from the CDN script
    if (typeof WebTorrent === 'function') {
      try { 
        client = new WebTorrent(); 
        client.on('error', (err) => {
          console.error('WebTorrent Client Error:', err);
          metaNotice.classList.remove('hidden');
          metaNotice.textContent = `Client Error: ${err.message}. Try reloading or using a native client.`;
        });
      } catch(e) { 
        console.error('WebTorrent init error', e); 
        metaNotice.classList.remove('hidden');
        metaNotice.textContent = 'Failed to create WebTorrent client instance.';
        client = null;
      }
    } else {
      console.error('WebTorrent library not loaded.');
      metaNotice.classList.remove('hidden');
      metaNotice.textContent = 'WebTorrent library failed to load. Check your network or CDN access.';
    }
  }
}

function startAddMagnet(rawInput) {
  const magnet = normalizeToMagnet(rawInput) || rawInput;
  clearUiState();

  if (!magnet || !magnet.startsWith('magnet:?')) {
    metaNotice.classList.remove('hidden');
    metaNotice.textContent = '‚ùå Invalid magnet link or info-hash. Paste a magnet:? link or a 40-char hash.';
    return;
  }

  // Always set up native fallback controls
  nativeActionRow.classList.remove('hidden');
  openNativeBtn.onclick = () => { window.location.href = magnet; };
  copyMagnetForNative.onclick = () => copyToClipboard(magnet, copyMagnetForNative);

  // If input is valid, proceed
  magnetInput.value = ''; // Clear input for next use
  addTorrent(magnet);
}

function addTorrent(magnetOrBuffer) {
  ensureClient();
  if (!client) return; // Client error already displayed by ensureClient

  if (activeTorrent) { 
    console.log('Destroying previous torrent.');
    try { activeTorrent.destroy(); } catch(e) { console.warn('Previous torrent destroy failed:', e); } 
    activeTorrent = null; 
  }
  clearInterval(statsUpdater);
  clearMetadataTimer();
  
  activeArea.classList.remove('hidden');

  // Set the 20s metadata timeout
  metadataTimer = setTimeout(()=> {
    if (activeTorrent && (!activeTorrent.files || !activeTorrent.files.length)) {
      metaNotice.classList.remove('hidden');
      metaNotice.textContent = '‚è≥ Unable to fetch metadata / connect to peers within 20s. Try "Open in native app".';
    }
  }, 20000);

  try {
    // Announce trackers are only needed for buffer/file input, but safe to pass always
    const options = { announce: DEFAULT_WSS_TRACKERS.split('&tr=').filter(t => t).map(decodeURIComponent) };
    
    client.add(magnetOrBuffer, options, (torrent) => {
      activeTorrent = torrent;
      torrentNameEl.textContent = torrent.name || 'Unnamed torrent';
      updateStats();

      // Start regular stat updates
      statsUpdater = setInterval(()=> {
        if (!activeTorrent) { clearInterval(statsUpdater); return; }
        updateStats();
      }, 700);

      // Handle metadata arrival
      torrent.on('metadata', () => { 
        torrentNameEl.textContent = torrent.name || 'Unnamed torrent'; // Update name if it wasn't available before
        populateFiles(torrent); 
        clearMetadataTimer(); 
      });

      // Handle download completion
      torrent.on('done', ()=> {
        progressBar.style.width = '100%';
        torrentStatsEl.textContent = `üéâ Completed ‚Ä¢ Peers: ${torrent.numPeers || 0}`;
        clearInterval(statsUpdater);
      });

      // Handle peer/wire connection updates
      torrent.on('wire', ()=> updateStats());

      // If files are immediately available (from .torrent file or cached), display them
      if (torrent.files && torrent.files.length) {
        populateFiles(torrent);
        clearMetadataTimer();
      }

    });
  } catch (err) {
    console.error('Add torrent error', err);
    metaNotice.classList.remove('hidden');
    metaNotice.textContent = `‚ùå Failed to add torrent. Reason: ${err.message}.`;
    clearMetadataTimer();
  }
}

function clearMetadataTimer() { if (metadataTimer) { clearTimeout(metadataTimer); metadataTimer = null; } }

function populateFiles(torrent) {
  filesList.innerHTML = '';
  if (!torrent.files || !torrent.files.length) {
    filesList.innerHTML = '<div class="text-xs text-slate-400">No files found in torrent metadata.</div>';
    return;
  }

  torrent.files.forEach(file => {
    // Initially deselect the file to prevent automatic full download
    try { if (typeof file.deselect === 'function') file.deselect(); } catch(e) {}
    
    const row = document.createElement('div');
    row.className = 'flex items-center justify-between gap-3 bg-slate-900/70 p-3 rounded-xl border border-slate-800';
    row.innerHTML = `
      <div class="min-w-0">
        <div class="text-sm font-medium text-slate-100 line-clamp-1">${escapeHtml(file.name)}</div>
        <div class="text-xs text-slate-400 mt-1">${(file.length / (1024*1024)).toFixed(2)} MB</div>
      </div>
      <div class="flex-shrink-0 flex items-center gap-2">
        <button class="btn-download px-3 py-2 rounded-lg bg-accent text-slate-950 text-xs font-semibold hover:bg-sky-500 transition">Download</button>
      </div>
    `;
    filesList.appendChild(row);

    const dlBtn = row.querySelector('.btn-download');
    dlBtn.addEventListener('click', () => {
      dlBtn.disabled = true;
      const originalText = dlBtn.textContent;
      dlBtn.textContent = 'Preparing...';

      // Select file to start fetching pieces
      try { if (typeof file.select === 'function') file.select(); } catch(e) { console.warn('file.select failed', e); }

      file.getBlob((err, blob) => {
        dlBtn.disabled = false; // Always re-enable button after attempt
        dlBtn.textContent = originalText;
        
        if (err || !blob) {
          console.error('getBlob error', err);
          dlBtn.textContent = '‚ùå Failed';
          setTimeout(()=> { dlBtn.textContent=originalText; }, 1400);
          return;
        }

        // Trigger file download
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = file.name;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        
        dlBtn.textContent = 'üíæ Saved';
        setTimeout(()=> { dlBtn.textContent=originalText; }, 1200);
      });
    });
  });
}

function updateStats() {
  if (!activeTorrent) return;
  const t = activeTorrent;
  const percent = Math.round((t.progress || 0) * 10000) / 100;
  progressBar.style.width = `${percent}%`;
  
  const totalMB = (t.length / (1024*1024)).toFixed(0);
  const downloadedMB = (t.downloaded / (1024*1024)).toFixed(1);
  const uploadSpeed = formatSpeed(t.uploadSpeed || 0);

  torrentStatsEl.textContent = `${percent}% (${downloadedMB}/${totalMB} MB) ‚Ä¢ ‚Üì ${formatSpeed(t.downloadSpeed || 0)}/s ‚Üë ${uploadSpeed}/s`;
  peerCountEl.textContent = `Peers: ${t.numPeers || 0}`;
}

function formatSpeed(bytesPerSec) {
  if (!bytesPerSec) return '0 KB';
  const units = ['B','KB','MB','GB'];
  let b = bytesPerSec;
  let u = 0;
  while (b >= 1024 && u < units.length-1) { b /= 1024; u++; }
  return `${b.toFixed(2)} ${units[u]}`;
}

/* ============
   UI wiring
   ============ */

addMagnetBtn.addEventListener('click', () => {
  const raw = magnetInput.value.trim();
  if (!raw) { magnetInput.focus(); return; }
  startAddMagnet(raw);
});

magnetInput.addEventListener('keydown', (e) => { 
  if (e.key === 'Enter') addMagnetBtn.click(); 
});

// File input logic
document.getElementById('chooseFileBtn').addEventListener('click', () => torrentFileInput.click());
torrentFileInput.addEventListener('change', (ev) => {
  const f = ev.target.files && ev.target.files[0];
  if (!f) { fileLabel.textContent = 'No file chosen'; return; }
  fileLabel.textContent = f.name;

  const reader = new FileReader();
  reader.onload = function() {
    const arr = new Uint8Array(this.result);
    startAddMagnet(f.name); // Clear UI and setup native button with *name* for context
    addTorrent(arr); // Add torrent using the ArrayBuffer
  };
  reader.onerror = function() {
    fileLabel.textContent = 'Read failed';
    metaNotice.classList.remove('hidden');
    metaNotice.textContent = '‚ùå Failed to read .torrent file.';
  };
  reader.readAsArrayBuffer(f);
});


// Destroy button logic
destroyBtn.addEventListener('click', () => {
  if (activeTorrent) {
    console.log('User stopped torrent.');
    try { activeTorrent.destroy(); } catch(e) {}
  }
  activeTorrent = null;
  clearInterval(statsUpdater);
  clearMetadataTimer();
  clearUiState();
});

/* cleanup on window close/reload */
window.addEventListener('beforeunload', () => {
  if (activeTorrent) try { activeTorrent.destroy(); } catch(e) {}
  if (client) try { client.destroy(); } catch(e) {}
});
</script>
</body>
</html>

